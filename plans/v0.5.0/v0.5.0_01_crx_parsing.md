# Plan: Proper CRX Parsing (v0.5.0)

## Goal

Replace the "find ZIP header" hack in `src/fetchext/utils.py` with a robust CRX3 parser.

## Current State

`src/fetchext/utils.py` reads the entire file into memory and searches for the ZIP signature `PK\x03\x04`. This is inefficient for large files and potentially inaccurate if the signature appears in the header.

## Specification (CRX3)

- **Magic**: `Cr24` (0x34327243)
- **Version**: 4 bytes (unsigned int, little-endian). Expected: 3.
- **Header Length**: 4 bytes (unsigned int, little-endian).
- **Header Data**: `Header Length` bytes (Protobuf).
- **Payload**: The rest of the file (ZIP archive).

## Implementation Plan

1. **Create `src/fetchext/crx.py`**:
    - Implement `CrxDecoder` class or helper functions.
    - Function `get_crx_zip_offset(file_path: Path) -> int`:
        - Open file in binary mode.
        - Read magic (4 bytes). If not `Cr24`, return 0 (assume plain ZIP or handle error).
        - Read version (4 bytes).
        - Read header length (4 bytes).
        - Calculate offset: `4 (Magic) + 4 (Version) + 4 (Length) + Header Length`.
        - Return offset.

2. **Update `src/fetchext/utils.py`**:
    - Use `get_crx_zip_offset` to determine where the ZIP starts.
    - Instead of reading the whole file into `BytesIO`, use a file-like object wrapper that seeks to the offset.
    - Since `zipfile.ZipFile` accepts a file-like object, we can pass the open file handle after seeking.
    - **Challenge**: `zipfile.ZipFile` might need random access. If we pass the open file object, we need to ensure we don't close it prematurely or that `ZipFile` handles it correctly.
    - Better approach: Create a `PartialFile` wrapper class that behaves like a file but starts at an offset. Or just seek and pass the file object, but `ZipFile` might try to seek to the beginning (0) which would be wrong for the ZIP structure relative to the file start?
    - Actually, `zipfile.ZipFile` works on a file object. If the file object is a standard file, `ZipFile` expects the central directory at the end. The offsets in the central directory are relative to the start of the *ZIP archive*.
    - If the ZIP is embedded in a CRX, the offsets in the ZIP might be relative to the start of the ZIP (0) or the start of the file?
    - In CRX files, the ZIP payload is just a concatenated ZIP file. So the offsets inside the ZIP are relative to the start of the ZIP stream.
    - If we pass a file object to `zipfile.ZipFile`, it uses it directly. If we seek to the offset, `zipfile` might still try to read from the end of the *file* to find the central directory.
    - Wait, if we just seek, `zipfile` might get confused if it tries to seek relative to the start of the file.
    - **Solution**: We might need a wrapper that offsets all seek operations. Or, simpler: `zipfile` allows opening a file-like object. If we provide a wrapper that subtracts the offset from `tell()` and adds it to `seek()`, it should work.
    - **Alternative**: Continue using `BytesIO` for now but only read the ZIP part? No, the goal is streaming.
    - **Refined Plan**:
        - Implement `PartialFileReader` class in `utils.py` or `crx.py`.
        - It wraps a file object and an offset.
        - `seek(pos, whence)`: Adjusts `pos` based on offset.
        - `read(n)`: Reads from underlying file.
        - `tell()`: Returns `real_tell() - offset`.

3. **Testing**:
    - Create unit tests with a mock CRX file (Magic + Version + Length + Header + ZIP).
    - Verify `zipfile` can open it using the new logic.
    - Verify it handles plain ZIPs (offset 0).

## Files to Modify

- `src/fetchext/utils.py`
- `src/fetchext/crx.py` (New)
- `tests/unit/test_crx.py` (New)

## Verification

- Run `make test`.
