# Plan: v0.7.0 - Signature Verification

## Goal

Implement `fext verify <file>` to cryptographically verify the integrity of a CRX file. This ensures the file has not been tampered with and was signed by the private key corresponding to the public key in the header.

## Requirements

1. **CLI Command**: `fext verify <file_path>`
2. **Input**: Path to a `.crx` file.
3. **Output**: Success/Failure message.
    - "Signature Verified (RSA-SHA256)"
    - "Verification Failed"
4. **Dependencies**: Need a crypto library. `cryptography` is the standard.

## Implementation Details

### 1. CRX3 Format Recap

- Magic: `Cr24`
- Version: `3`
- Header Length: 4 bytes
- Header: Protobuf (`CrxFileHeader`) containing `Sha256WithRsa` signature and `SignedData`.
- `SignedData` contains the CRX ID (public key hash).
- The signature verifies the `SignedData` + the ZIP payload.
- Wait, CRX3 is complex. It uses Protobuf.
  - I might need `protobuf` dependency or a manual parser if the proto is simple.
  - The header is a serialized protobuf.
  - If I don't want to compile protos, I can try to reverse engineer the bytes or use a lightweight parser.
  - Actually, `CrxDecoder` in `utils.py` already parses the header length.
  - I need to parse the Protobuf message.
  - Maybe I can skip full verification if it's too complex for "minimal dependencies".
  - But the roadmap says "Validate the cryptographic signature".
  - Let's try to use `cryptography` and maybe a minimal protobuf decoder or just `google.protobuf` if needed.
  - Actually, for a CLI tool, `cryptography` + `protobuf` is a lot of weight.
  - Alternative: Just verify the file structure and magic numbers for now?
  - No, the prompt asked for "Signature Verification".
  - Let's add `cryptography` and `protobuf`.

### 2. Core Logic (`src/fetchext/verifier.py`)

- Class `CrxVerifier`.
- Method `verify(file_path) -> bool`.
- Steps:
    1. Read CRX header.
    2. Parse Protobuf header (needs `crx3.proto` definition or equivalent).
    3. Extract Public Key, Signature, and Signed Data.
    4. Verify: `RSA.verify(signature, signed_data + zip_data, public_key)`.
  - CRX3 signature covers: `prefix (magic + version + header_len) + header + zip_data`?
  - Actually, CRX3 is:
    - Magic (4)
    - Version (4)
    - Header Size (4)
    - Header (Protobuf)
    - Archive (Zip)
  - The signature is INSIDE the Header.
  - The signature signs the `SignedData` (which is also inside the header) + the Archive?
  - According to docs: The signature is over `signed_header_data + archive_data`.
  - `signed_header_data` is a field in the Header.

### 3. Dependencies

- Add `cryptography` to `pyproject.toml`.
- Add `protobuf` to `pyproject.toml`.

### 4. CLI (`src/fetchext/cli.py`)

- Add `verify` subcommand.

## Testing Strategy

1. **Unit Tests**:
    - Test with a valid CRX (need a real one or a carefully constructed mock).
    - Test with a tampered CRX (flip a bit in the zip).

## Tasks

- [ ] Add dependencies.
- [ ] Create `src/fetchext/protos/crx3.proto` (or python equivalent).
- [ ] Implement `CrxVerifier`.
- [ ] Add `verify` command.
- [ ] Add tests.
